I"˝X<blockquote>
  <p>This tutorial will guide you through the steps required to have a process-type service registered onto the SingularityNET. It assumes you have successfully installed all of SingularityNET components. To do that, refer to previous tutorials or simply run a docker container from the <a href="./Dockerfile">Dockerfile</a> provided. If you choose to run a Docker container, make sure to expose a port so that SNET Daemon can communicate with the blockchain.</p>
</blockquote>

<p>SingularityNET is an open-source protocol and collection of smart contracts for a decentralized market of coordinated AI services. Within this framework, anyone can add an AI/machine learning service to SingularityNET for use by the network and receive network payment tokens in exchange.</p>

<p>As an AI/machine learning service developer, you can expose your service to the SingularityNET by running an instance of SNET Daemon alongside it. The Daemon interacts with the blockchain to facilitate authorization and payment for services and acts as a pass-through for making API calls to the service.  There are currently 3 ways by which the Daemon can communicate with a service:</p>

<ul>
  <li>Through stdin/stdout as an executable/process;</li>
  <li>Through JSON-RPC;</li>
  <li>Through gRPC.</li>
</ul>

<p>This tutorial will guide you through integrating process-type services that receive their input from SNET Daemon via the standard input stream (<code class="highlighter-rouge">stdin</code>) and return their output via the standard output stream (<code class="highlighter-rouge">stdout</code>). If you‚Äôre already familiar with SingularityNET and know how to create, publish and call a service that communicates with SNET Daemon through JSON-RPC or gRPC, you can skip to the <a href="#summary">Summary</a> section.</p>

<p>The main steps of this tutorial are:</p>

<ol>
  <li><a href="#step-1-writing-the-code-for-your-service">Write the code for your service</a> taking and returning well-defined JSON data via stdin and stdout;</li>
  <li><a href="#step-2-publishing-the-service-onto-singularitynet">Publish it as an SNET service</a>:
    <ol>
      <li><a href="#step-21-specifying-the-service-model">Specify the service model (protobuf file)</a></li>
      <li><a href="#step-22-create-the-service-metadata">Create the service metadata</a></li>
      <li><a href="#step-23-publish-the-service-under-your-organization">Publish the service under your organization</a></li>
      <li><a href="#step-24-running-snet-daemon">Running SNET Daemon</a></li>
    </ol>
  </li>
  <li><a href="#step-3-calling-your-service">Call the service</a>.</li>
</ol>

<h2 id="step-1-writing-the-code-for-your-service">Step 1) Writing the code for your service</h2>

<p>For this tutorial we‚Äôll write an example executable service in <a href="https://www.python.org/">Python</a> but this approach can be applied to other programming languages as well.</p>

<p>To keep the directory structure of the services and follow the standard file paths, we‚Äôll create the following directories:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> example-executable-service/service/service_spec <span class="o">&amp;&amp;</span> <span class="se">\</span>
<span class="nb">cd </span>example-executable-service/service
</code></pre></div></div>

<p>Inside the service folder, create a file for the main code of your service (in our case, <code class="highlighter-rouge">example-executable-service.py</code>). For demonstration purposes, we‚Äôll create a very simple service that adds two numbers. Here‚Äôs the Python code for it, have a look at the code and its comments.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># Setting up a logger to log to a file.
# This is extra relevant in the case of a process-type service because SNET Daemon captures everything that is printed
# to stdout. If anything other than the json it expects is printed, a parsing error will be raised.
</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">"basic_template"</span><span class="p">)</span>
<span class="n">file_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="s">'executable_service.log'</span><span class="p">)</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s">"</span><span class="si">%(asctime)</span><span class="s">s - [</span><span class="si">%(levelname)8</span><span class="s">s] - </span><span class="si">%(name)</span><span class="s">s - </span><span class="si">%(message)</span><span class="s">s"</span><span class="p">)</span>
<span class="n">file_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">"Running service."</span><span class="p">)</span>

    <span class="c1"># Read the method defined in the .proto file from argv.
</span>    <span class="n">method</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">"RECEIVED - Method: {}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">"add"</span><span class="p">:</span>
        <span class="c1"># Read input parameters from stdin
</span>        <span class="k">with</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">:</span>
            <span class="n">input_args</span> <span class="o">=</span> <span class="s">""</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">:</span>
                <span class="n">input_args</span> <span class="o">+=</span> <span class="n">line</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">input_args</span><span class="p">)</span>  <span class="c1"># Converts from string to python dict
</span>        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">"STDIN: {}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">input_args</span><span class="p">))</span>

        <span class="c1"># Add arguments
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"a"</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s">"b"</span><span class="p">]</span>  <span class="c1"># Dictionary key names must match the specifications in .proto.
</span>
        <span class="c1"># Build the resulting json from a dictionary
</span>        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="s">"value"</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>  <span class="c1"># Dictionary key names must match the specifications in .proto.
</span>        <span class="n">json_return</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">return_dict</span><span class="p">)</span>

        <span class="c1"># Return the resulting json and exit
</span>        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json_return</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">"STDOUT: {}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">json_return</span><span class="p">))</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># This condition will never happen because snet-cli won't allow methods unknown to it (i.e. not in .proto file).
</span>        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<p>To test this code locally, run <code class="highlighter-rouge">./example-executable-service.py add &lt;&lt;&lt; '{"a": 2.1, "b":6.7}'</code> and it should return <code class="highlighter-rouge">{"value": 8.8}</code>.</p>

<p>Notice that:</p>
<ul>
  <li>The service method (‚Äúadd‚Äù, in this case) will be received through <code class="highlighter-rouge">argv[1]</code> while the remaining parameters will be received through stdin;</li>
  <li>Once your code is ready, avoid printing any debug or status messages since they‚Äôll be sent to <code class="highlighter-rouge">stdout</code>, where SNET Daemon awaits the JSON-encoded return data;</li>
  <li>Since this code will be interpreted as executable, you need to tell your operating system what interpreter to use by adding the shebang <code class="highlighter-rouge"><span class="c1">#!/usr/bin/env python3</span></code>, for Python3, or an equivalent for your programming language of choice. You also need to give executable permissions to it, in our case, by running <code class="highlighter-rouge">chmod +x example-executable-service.py</code>.</li>
</ul>

<h2 id="step-2-publishing-the-service-onto-singularitynet">Step 2) Publishing the service onto SingularityNET</h2>

<h3 id="step-21-specifying-the-service-model">Step 2.1) Specifying the service model</h3>

<p>After writing the code for your service, you should now specify its user interface: the service model. We do that through a <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a> file, in which we define <code class="highlighter-rouge">services</code> (or methods) and their inputs and outputs (<code class="highlighter-rouge">messages</code>). By default, the <code class="highlighter-rouge">.proto</code> file is stored inside the <code class="highlighter-rouge">service/service_spec</code> folder. Below is the protobuf file for our example executable service that defines the <code class="highlighter-rouge">add</code> method, the <code class="highlighter-rouge">Numbers</code> message containing the two numbers to added, <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>, and the <code class="highlighter-rouge">Result</code> message returning their sum. It is a very simple example of a protobuf file, <a href="https://developers.google.com/protocol-buffers/docs/proto3">learn more</a> about protobuf syntax for more complex service models.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syntax <span class="o">=</span> <span class="s2">"proto3"</span><span class="p">;</span>

message Numbers <span class="o">{</span>
    float a <span class="o">=</span> 1<span class="p">;</span>
    float b <span class="o">=</span> 2<span class="p">;</span>
<span class="o">}</span>

message Result <span class="o">{</span>
    float value <span class="o">=</span> 1<span class="p">;</span>
<span class="o">}</span>

service Addition <span class="o">{</span>
    rpc add<span class="o">(</span>Numbers<span class="o">)</span> returns <span class="o">(</span>Result<span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You should copy this code into an <code class="highlighter-rouge">example-executable-service.proto</code> file inside <code class="highlighter-rouge">example-executable-service/service/service_spec</code>.</p>

<h3 id="step-22-create-the-service-metadata">Step 2.2) Create the service metadata</h3>

<p>A service metadata is a series of JSON-encoded information relative to the service that is necessary to publish it. It tells the blockchain where to redirect client calls to (your service endpoints), its encoding, price, etc. (refer to SNET CLI‚Äôs help for a list of all possible parameters).</p>

<p>At the root directory of your service, create a service metadata file by running <code class="highlighter-rouge">snet service metadata-init PROTOBUF_DIRECTORY DISPLAY_NAME PAYMENT_ADDRESS</code>, in which:</p>

<ul>
  <li><code class="highlighter-rouge">PROTOBUF_DIRECTORY</code> tells SNET CLI where to find the <code class="highlighter-rouge">.proto</code> file for your service;</li>
  <li><code class="highlighter-rouge">DISPLAY_NAME</code> is your service‚Äôs display name;</li>
  <li><code class="highlighter-rouge">PAYMENT_ADDRESS</code> is the public key of the blockchain key-pair that will receive the payments from client calls.</li>
</ul>

<p>You‚Äôll also need to specify:</p>
<ul>
  <li>The price in cogs for each client call by adding the <code class="highlighter-rouge">--fixed-price PRICE_IN_COGS</code> parameter;</li>
  <li>Your services endpoints <code class="highlighter-rouge">--endpoints http://IP:PORT</code>;</li>
  <li>And, because the Daemon will call our service as a process and pass parameters using JSON encoding , specify the <code class="highlighter-rouge">--service-type process --encoding json</code> parameters as well. The full command for our service is shown below. Make sure to change the <code class="highlighter-rouge">PAYMENT_ADDRESS</code> and the <code class="highlighter-rouge">endpoints</code> accordingly before running it.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snet service metadata-init service/service_spec example-executable-service 0xD416d832F6AE2Ca7d9C7C05f9255Ab49b70c0fe4 <span class="nt">--endpoints</span> http://54.203.198.53:7018 <span class="nt">--fixed-price</span> 0 <span class="nt">--service-type</span> process <span class="nt">--encoding</span> json 
</code></pre></div></div>

<p>That will generate a <code class="highlighter-rouge">service_metadata.json</code> file at the root of your service directory that should look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "version": 1,
    "display_name": "example-executable-service",
    "encoding": "json",
    "service_type": "process",
    "payment_expiration_threshold": 40320,
    "model_ipfs_hash": "QmUW63oG2RX6e84kWSH6yLzXKtvrhcT4QUNLfvxHDq3Y7X",
    "mpe_address": "0x39f31Ac7B393fE2C6660b95b878FEB16eA8f3156",
    "pricing": {
       "price_model": "fixed_price",
       "price_in_cogs": 0
   },
    "groups": [
        {
            "group_name": "default_group",
            "group_id": "9Z5VigBPqcIOtVwbCFyos5aLk9iNXD8aZAfAdmen2aU=",
            "payment_address": "0xCEb196e0236C5B4EE62d5C87692284FBd52fCBD0"
        }
    ],
    "endpoints": [
        {
            "group_name": "default_group",
            "endpoint": "http://54.203.198.53:7018"
        }
    ]
}
</code></pre></div></div>

<h3 id="step-23-publish-the-service-under-your-organization">Step 2.3) Publish the service under your organization</h3>

<p>Publish your service by running <code class="highlighter-rouge">snet service publish ORGANIZATION_ID SERVICE_ID</code>. In our example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snet service publish my_organization example-executable-service
</code></pre></div></div>

<p>Confirm the transaction and the blockchain should now be aware of your service!</p>

<blockquote>
  <p>After having published your service, both its <code class="highlighter-rouge">service_metadata.json</code> and its service model/specifications (<code class="highlighter-rouge">.proto</code> file) will have been stored in IPFS, so if you change these files locally, you‚Äôll need to update them. Have a look at <code class="highlighter-rouge">snet service update-metadata</code> and <code class="highlighter-rouge">snet service metadata-set-model</code> commands for that.</p>
</blockquote>

<h3 id="step-24-running-snet-daemon">Step 2.4) Running SNET Daemon</h3>

<p>To run your service, you simply need to run an instance of SNET Daemon at the specified endpoint. It will listen to client calls at the blockchain and execute your service at the specified path using the client parameters. SNET Daemon takes a configuration file that specifies which network it should listen to (e.g. Kovan Testnet), where to redirect calls to, etc. (refer to <a href="https://github.com/singnet/snet-daemon">SNET Daemon‚Äôs Github Repository</a> for the complete list of parameters). By default, the daemon configuration file should be created at the root directory of your service and be called <code class="highlighter-rouge">snetd.config.json</code>. Here‚Äôs the example configuration file for our service (again, make sure to change the parameters accordingly before saving):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   "DAEMON_END_POINT": "http://54.203.198.53:7018",
   "ETHEREUM_JSON_RPC_ENDPOINT": "https://kovan.infura.io",
   "IPFS_END_POINT": "http://ipfs.singularitynet.io:80",
   "REGISTRY_ADDRESS_KEY": "0xe331bf20044a5b24c1a744abc90c1fd711d2c08d",
   "PASSTHROUGH_ENABLED": true,
   "EXECUTABLE_PATH": "./service/example-executable-service.py",
   "ORGANIZATION_ID": "my_organization",
   "SERVICE_ID": "example-executable-service",
   "PAYMENT_CHANNEL_STORAGE_SERVER": {
       "DATA_DIR": "/opt/singnet/etcd/"
   },
   "LOG": {
       "LEVEL": "debug",
       "OUTPUT": {
              "TYPE": "stdout"
           }
   }
}
</code></pre></div></div>

<p>You‚Äôre now able to keep an instance of SNET Daemon running at your service directory to keep it available:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snetd serve <span class="nb">.</span>
</code></pre></div></div>

<h2 id="step-3-calling-your-service">Step 3) Calling your service</h2>

<p>To call your service through the blockchain, make sure you have sufficient funds for the transactions (check by running <code class="highlighter-rouge">snet account balance</code>). If you don‚Äôt, deposit an amount (e.g. 10 COGs, or 10e-8 AGI) by running <code class="highlighter-rouge">snet account deposit 0.00000010</code>.</p>

<p>Create a payment channel to your service: specify its organization and service IDs, deposit some tokens into the channel and set its expiration time: <code class="highlighter-rouge">snet channel open-init ORG_ID SERVICE_ID AMOUNT EXPIRATION</code>. For our example, we‚Äôll deposit 0 tokens and set the payment channel to expire in 10 days:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snet channel open-init my_organization example-executable-service 0 +10days
</code></pre></div></div>

<p>Confirm the transaction and that should print the number of the channel you have opened (you can always check again by running <code class="highlighter-rouge">snet channel print-initialized</code>). Supposing your channel number is <code class="highlighter-rouge">450</code>, you will spend <code class="highlighter-rouge">0</code> cogs and call the service at <code class="highlighter-rouge">54.203.198.53:7018</code> here‚Äôs an example of how to call the service you have just published:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snet client call 450 0 54.203.198.53:7018 add <span class="s1">'{"a": 6.3, "b": 13.2}'</span>
</code></pre></div></div>

<p>It should then return:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>value: 19.5
</code></pre></div></div>

<p>That‚Äôs it! You should now have a working process-type service published onto SingularityNET!</p>

<h2 id="summary">Summary</h2>

<p>If you‚Äôre already familiar with how to publish SingularityNET services, here‚Äôs a summary of what changes when dealing with process-type services:</p>

<ul>
  <li>Make sure your service code has a shebang line (e.g. <code class="highlighter-rouge"><span class="c1">#!/usr/bin/env python3</span></code>, executable permissions (change that by running <code class="highlighter-rouge">chmod +x SERVICE_CODE</code>) and the only data it sends to stdout is the returning message defined at the protobuf file;</li>
  <li>Specify <code class="highlighter-rouge">--service-type process</code> and <code class="highlighter-rouge">--encoding json</code> when running <code class="highlighter-rouge">snet service metadata-init</code> or manually change that in <code class="highlighter-rouge">service_metadata.json</code>;</li>
  <li>Add <code class="highlighter-rouge">"EXECUTABLE_PATH": "PATH_TO_EXECUTABLE"</code> in <code class="highlighter-rouge">snetd.config.json</code>.</li>
</ul>
:ET